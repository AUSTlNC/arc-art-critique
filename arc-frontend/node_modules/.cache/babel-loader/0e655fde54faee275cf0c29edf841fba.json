{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = _interopRequireDefault(require(\"../validators/is\"));\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"../validators/isValidIdentifier\"));\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"MemberExpression\")\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\n(0, _utils.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\n(0, _utils.default)(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\n(0, _utils.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n(0, _utils.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\n(0, _utils.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\n(0, _utils.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\n(0, _utils.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Import\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\n(0, _utils.default)(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});","map":{"version":3,"sources":["/Users/AustinCai/Desktop/CS 370/ARC/Arc-FrontEnd-2.0/node_modules/@babel/types/lib/definitions/core.js"],"names":["Object","defineProperty","exports","value","classMethodOrDeclareMethodCommon","classMethodOrPropertyCommon","patternLikeCommon","functionDeclarationCommon","functionTypeAnnotationCommon","functionCommon","_is","_interopRequireDefault","require","_isValidIdentifier","_helperValidatorIdentifier","_constants","_utils","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","fields","elements","validate","chain","assertValueType","assertEach","assertNodeOrValueType","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","identifier","assertOneOf","ASSIGNMENT_OPERATORS","pattern","node","val","validator","left","assertNodeType","right","builder","BINARY_OPERATORS","expression","inOp","oneOfNodeTypes","directives","body","label","optional","assign","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","each","tokens","type","init","update","params","generator","async","returnType","declare","id","parent","inherits","typeAnnotation","decorators","name","TypeError","match","exec","parentKey","nonComp","computed","imported","meta","isKeyword","isReservedWord","deprecatedAlias","flags","invalid","LOGICAL_OPERATORS","object","property","normal","sourceFile","sourceType","interpreter","properties","kind","shorthand","argument","Error","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","without","definite","superClass","superTypeParameters","implements","mixins","abstract","source","exportKind","validateOptional","assertions","declaration","specifiers","sourced","sourceless","local","exported","lval","await","importKind","accessibility","static","access","tag","quasi","assertShape","raw","cooked","tail","quasis","delegate","assertOptionalChainStart"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = _interopRequireDefault(require(\"../validators/is\"));\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"../validators/isValidIdentifier\"));\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"MemberExpression\")\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\n(0, _utils.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\n(0, _utils.default)(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\n(0, _utils.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n(0, _utils.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\n(0, _utils.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\n(0, _utils.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\n(0, _utils.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Import\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\n(0, _utils.default)(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});"]},"metadata":{},"sourceType":"script"}